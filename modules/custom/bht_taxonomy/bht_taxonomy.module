<?php


/**
 * Implements hook_menu_alter().
 *
 * Override the Drupal default taxonomy term menu path.
 */
function bht_taxonomy_menu_alter(&$items) {
  // Add a new page callback for taxonomy term paths.
  $items['taxonomy/term/%taxonomy_term']['page callback'] = 'bht_taxonomy_term_page';
  // Unset the file and module attributes.
  unset($items['taxonomy/term/%taxonomy_term']['file']);
  unset($items['taxonomy/term/%taxonomy_term']['module']);
}


/**
 * Implements hook_form_alter().
 */
function bht_taxonomy_form_alter(&$form, &$form_state, $form_id) {
  if (module_exists('i18n_taxonomy') && !isset($form['delete'])) {
    switch ($form_id) {
      case 'taxonomy_form_term':
        // Hide the description field in favour of the body field.
        $form['description']['#access'] = FALSE;

        // Force the term language if the mode is set to "Translate".
        if ($form['#vocabulary']->i18n_mode == I18N_MODE_TRANSLATE) {
          // Get the required language taxonomy setting.
          $req_lang = variable_get(
            'bht_taxonomy_require_language', array()
          );
          // Check if the current vocabulary requires a language.
          if (!empty($req_lang[$form['#vocabulary']->machine_name])) {
            // Unset the neutral language from the options list.
            if (isset($form['language']['#options'][LANGUAGE_NONE])) {
              unset($form['language']['#options'][LANGUAGE_NONE]);
            }
          }
        }
        break;

      case 'taxonomy_form_vocabulary':
        // Similar to nodes, add a require language checkbox if the vocabulary is set to "Translate".
        $form['i18n_translation']['require_language'] = array(
          '#type' => 'checkbox',
          '#title' => t(
            'Require language (Do not allow Language Neutral).'
          ),
          '#states' => array('visible' => array('input[name="i18n_mode"]' => array('value' => I18N_MODE_TRANSLATE)))
        );
        // Add a custom submit handler to handle the require language checkbox.
        $form['#submit'][] = '_bht_taxonomy_submithandler';
        break;

      default:
        break;
    }
  }
}

/**
 * Callback function for taxonomy page.
 */
function bht_taxonomy_term_page($term) {
  // Support for i18n.
  if (module_exists('i18n_taxonomy')) {
    $term = i18n_taxonomy_localize_terms($term);
  }

  // Set page title.
  drupal_set_title($term->name);

  // Build breadcrumb based on the hierarchy of the term.
  $breadcrumb = array();
  $current = (object) array('tid' => $term->tid);
  // The tree goes from end to start.
  while ($parents = taxonomy_get_parents($current->tid)) {
    $current = array_shift($parents);
    $breadcrumb[] = l($current->name, 'taxonomy/term/' . $current->tid);
  }
  $breadcrumb[] = l(t('Home'), NULL);
  // Change breadcrumb to chronological order.
  $breadcrumb = array_reverse($breadcrumb);
  // Set the breadcrumb.
  drupal_set_breadcrumb($breadcrumb);

  // Build the uri for the head section.
  $uri = entity_uri('taxonomy_term', $term);
  // Ensure the correct language.
  if (isset($term->language) && $term->language != LANGUAGE_NONE) {
    $languages = language_list();
    $uri['options']['language'] = $languages[$term->language];
  }
  // Although the system path will never be used,
  // we need to provide the canonical url, the alias must be indexed,
  // we don't provide the shortlink with the system path, no need to index that.
  drupal_add_html_head_link(
    array(
      'rel' => 'canonical',
      'href' => url($uri['path'], $uri['options'])
    ), TRUE
  );

  // Build the renderable array with the full view mode.
  $build['term'] = taxonomy_term_view($term, 'full');

  return $build;
}


/**
 * Implements hook_field_extra_fields().
 * We use this hook to get our Children & Content in the Manage Display form
 */
function bht_taxonomy_field_extra_fields() {
  $extra = array();
  $info = entity_get_info('taxonomy_term');

  foreach (array_keys($info['bundles']) as $bundle) {
    $extra['taxonomy_term'][$bundle]['display'] = array(
      // Taxonomy children.
      'taxonomy_children' => array(
        'label' => t('Taxonomy children'),
        'description' => t('Taxonomy children'),
        'weight' => -99,
      ),
      // Taxonomy content.
      'taxonomy_content' => array(
        'label' => t('Taxonomy content'),
        'description' => t('Taxonomy content'),
        'weight' => -99,
      ),
    );
  }

  return $extra;
}


/**
 * Implements hook_field_extra_fields_alter().
 * Hides the description field under manage fields and manage display.
 */
function bht_taxonomy_field_extra_fields_alter(&$info) {
  if (isset($info['taxonomy_term'])) {
    foreach ($info['taxonomy_term'] as &$vocabulary) {
      unset($vocabulary['form']['description']);
      unset($vocabulary['display']['description']);
    }
  }
}


/**
 * Implements hook taxonomy_term_view().
 *
 * The module may add elements to $term->content prior to rendering. The
 * structure of $term->content is a renderable array as expected by
 * drupal_render().
 *
 * @param $term
 * @param $view_mode
 * @param $langcode
 */
function bht_taxonomy_taxonomy_term_view($term, $view_mode, $langcode) {
  // Check the display settings of our extra fields.
  $display = field_extra_fields_get_display(
    'taxonomy_term', $term->vocabulary_machine_name, $view_mode
  );
  $display_children = (!empty($display['taxonomy_children'])) ? TRUE : FALSE;
  $display_content = (!empty($display['taxonomy_content'])) ? TRUE : FALSE;

  // Attach the term children.
  if ($display_children) {
    $output_children = array();

    // Allow other modules to take over the building of the term_children.
    if ($modules = _get_module_implementations('taxonomy_get_children')) {
      // Loop over each module that implements term_get_children.
      foreach ($modules as $module) {
        // Give each module the chance to take over.
        if ($children = module_invoke(
          $module, 'taxonomy_get_children', $term
        )
        ) {
          // Quit processing when children are returned.
          break;
        }
      }
    }


    // Build the term_children renderable array based on the invoked array.
    if (isset($children) && $children && is_array($children)) {
      $output_children = $children;
    }
    // Provide module own implementation of term_children.
    elseif ($tids = taxonomy_get_children($term->tid)) {
      $children = taxonomy_term_view_multiple(
        $tids, 'taxonomy_children', $langcode
      );

      // Build the renderable array.
      $output_children = array(
        '#theme' => 'taxonomy_children',
        '#items' => $children['taxonomy_terms'],
        '#vid' => $term->vid,
      );
    }

    // Set renderable array of term_children.
    $term->content['taxonomy_children'] = $output_children;
  }

  // Attach the term content.
  if ($display_content) {
    $output_content = array();

    // Allow other modules to take over the building of the term_content.
    if ($modules = _get_module_implementations('taxonomy_get_content')) {
      // Loop over each module that implements term_get_content.
      foreach ($modules as $module) {
        // Give each module the chance to take over.
        if ($content = module_invoke($module, 'taxonomy_get_content', $term)) {
          // Quit processing when content are returned.
          break;
        }
      }
    }

    // Build the term_content renderable array based on the invoked array.
    if (isset($content) && $content && is_array($content)) {
      $output_content = $content;
    }
    // Provide module own implementation of term_content.
    elseif ($nids = taxonomy_select_nodes(
      $term->tid, TRUE, variable_get(
      'taxonomy_content_items', 12
    )
    )
    ) {
      $nodes = node_load_multiple($nids);
      $content = node_view_multiple($nodes, 'taxonomy_content');

      // Build the renderable array.
      $output_content = array(
        '#theme' => 'taxonomy_content',
        '#items' => $content['nodes'],
        '#vid' => $term->vid,
        '#pager' => array('#theme' => 'pager'),
      );
    }

    // Set renderable array of term_content.
    $term->content['taxonomy_content'] = $output_content;
  }
}


/**
 * Implements hook_taxonomy_vocabulary_insert().
 * Adds a body field to the vocabulary.
 */
function bht_taxonomy_taxonomy_vocabulary_insert($vocabulary) {
  // Check if the taxonomy body exists.
  $field = field_info_field('taxonomy_body');

  if (empty($field)) {
    // Define the taxonomy body field.
    $field = array(
      'field_name' => 'taxonomy_body',
      'type' => 'text_with_summary'
    );

    // Create the taxonomy body field.
    $field = field_create_field($field);
  }

  // Check if the taxonomy body instance exists.
  $instance = field_info_instance(
    'taxonomy_term', 'taxonomy_body', $vocabulary->machine_name
  );

  if (empty($instance)) {
    // Define the taxonomy body instance.
    $instance = array(
      'field_name' => 'taxonomy_body',
      'entity_type' => 'taxonomy_term',
      'bundle' => $vocabulary->machine_name,
      'label' => 'Body',
      'widget' => array(
        'type' => 'text_textarea_with_summary',
        'weight' => -1
      ),
      'settings' => array('display_summary' => TRUE),
      'display' => array(
        'default' => array(
          'label' => 'hidden',
          'type' => 'text_default',
          'weight' => -1
        ),
        'teaser' => array(
          'label' => 'hidden',
          'type' => 'text_summary_or_trimmed',
          'weight' => -1
        ),
      ),
    );

    // Create the taxonomy body instance.
    $instance = field_create_instance($instance);
  }

  return $instance;
}


/**
 * Check the implementations of a hook, if any.
 *
 * @param string $hook
 *   Possible hook name.
 *
 * @return array
 *   The name of the last implementation of the hook,
 *   FALSE on error.
 */
function _get_module_implementations($hook) {
  $modules = module_implements($hook, FALSE);

  if (!$modules || !is_array($modules) || empty($modules)) {
    return FALSE;
  }

  return array_reverse($modules, TRUE);
}


/**
 * Retrieve a list of children term ids from a given vocabulary and term id.
 *
 * @param int $vid
 *   The requested vocabulary id.
 * @param int $tid
 *   The requested taxonomy term id.
 *
 * @return array
 *   A list of unique taxonomy term ids.
 */
function _bht_taxonomy_get_child_tids($vid, $tid) {
  $children = taxonomy_get_tree($vid, $tid);

  $tids = array(
    $tid,
  );

  if (!$children) {
    return $tids;
  }

  foreach ($children as $child) {
    $tids[] = $child->tid;
  }

  return array_unique($tids);
}


/**
 * Implements hook_entity_info_alter().
 */
function bht_taxonomy_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['taxonomy_content'] = array(
    'label' => t('Taxonomy content'),
    'custom settings' => TRUE,
  );

  $entity_info['taxonomy_term']['view modes']['taxonomy_children'] = array(
    'label' => t('Taxonomy children'),
    'custom settings' => TRUE,
  );
}

/**
 * Implements hook_theme().
 */
function bht_taxonomy_theme() {
  return array(
    'taxonomy_children' => array(
      'template' => 'templates/taxonomy-children',
      'variables' => array(
        'items' => array(),
        'vid' => NULL,
      ),
    ),
    'taxonomy_content' => array(
      'template' => 'templates/taxonomy-content',
      'variables' => array(
        'items' => array(),
        'vid' => NULL,
        'pager' => array(),
      ),
    ),
  );
}


/**
 * Implements template_preprocess_HOOK().
 */
function bht_taxonomy_preprocess_taxonomy_content(&$variables) {
  if (isset($variables['vid']) && !is_null($variables['vid'])) {
    $variables['theme_hook_suggestions'][] = "taxonomy_content__" . $variables['vid'];
  }
}


/**
 * Implements template_preprocess_HOOK().
 */
function bht_taxonomy_preprocess_taxonomy_children(&$variables) {
  if (isset($variables['vid']) && !is_null($variables['vid'])) {
    $variables['theme_hook_suggestions'][] = "taxonomy_children__" . $variables['vid'];
  }
}
